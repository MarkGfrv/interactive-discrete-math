import { GetQuery, TemplateItem, TemplatePromiseItem, Tuple } from '../types/common-types.ts';
import { ContentType } from '../types/message-types.ts';
type criteria<T extends boolean> = {
    type: 'or' | 'and';
    values: ({
        content: T extends true ? number[] : string;
    } | (T extends true ? FullCriteria : Criteria))[];
    subaliases?: Set<string>;
};
export type Criteria = criteria<false> | (criteria<false> & {
    v: string;
});
export type FullCriteria = criteria<true> | (criteria<true> & {
    v: string;
});
type Args = {
    template: Tuple<TemplatePromiseItem, 3>[];
    pre_template: Tuple<TemplatePromiseItem, 3>[];
    buffer: Tuple<TemplatePromiseItem, 3>[];
    bufferCurrent: string;
    bufferBranches: Map<string, {
        property: string;
        relationAlias: string;
    }>;
    current: string | number | Promise<number>;
    index: number;
    initial: string;
    branches: Map<string, string>;
    filteringTree: Criteria[];
    contentStack: Map<string, {
        content: string | number[];
    }>;
    contentAliases: Set<string>;
    addrFindValues: number[][];
    isDollar: boolean;
    isReverse: boolean;
    innerHats: {
        searchTarget: MagicHat;
        current: string;
        key: string;
        isReverse: boolean;
        customRelation?: any;
        dynamicRoot?: any;
        insertPosition?: number;
    }[];
    linksToFill: {
        [alias: string]: {
            data: string | number;
            type: ContentType;
        };
    };
    globalAliases: {
        [alias: string]: string;
    };
    exposeResponse?: true;
    exposedResponse?: {
        addrs: number[][];
        aliases: Record<string, number>;
    };
    aliasItems: Map<string, TemplatePromiseItem>;
    edgeData: Map<string, Tuple<TemplatePromiseItem, 3>>;
    dynamicRoot?: {
        type: 'alias';
        value: string;
    } | number;
    relations: (string | number)[];
    getQuery: GetQuery;
};
export type MagicHat = Args & {
    get currentItem(): TemplateItem;
    get clone(): MagicHat;
    resolveBuffer(): void;
    createPushTemplateItem: (type: 'template' | 'buffer', aliasV: string, property: string, aliasE: string) => (item: Tuple<TemplatePromiseItem, 3>) => void;
};
export declare const defaults: () => Args;
export declare class Hat {
    static isInstanceFlag: symbol;
    static [Symbol.hasInstance](obj: Record<PropertyKey, unknown>): obj is MagicHat;
}
export declare const getProxySource: (callable?: boolean) => {};
/**
 * Magic Hat is used instead of a class in order to make all properties non-enumerable
 * and prevent explicit disclosure of internal state (e.g. when logging a proxy).
 * Note that all properties remain accessible via `getOwnPropertyDescriptor`.
 */
export declare const createMagicHat: (args?: Args, callable?: boolean) => MagicHat;
export {};
