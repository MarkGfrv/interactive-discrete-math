import { Signal } from '@preact/signals';
import { $And } from '../magic/and.ts';
import { DisposableObject } from './common-types.ts';
type Disposable<T> = T & DisposableObject;
type UnionToIntersection<T> = (T extends unknown ? (x: T) => void : never) extends (x: infer I) => void ? I : never;
type OneOrMany<T> = T | T[];
type NonEmpty<T, U = {
    [K in keyof T]: Pick<T, K>;
}> = Partial<T> & U[keyof U];
type GCP<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>> = {
    [K in keyof Q[T] as CircularGuard<K, R, Q[T][K], P>]: MyTypes<Q>[T][K];
};
type PureConcept<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>, simple = false> = GCP<Q, P, R, T> & (simple extends true ? {
    ref: Ref<Q, T>;
} : RefMaker<Q, T>) & GetMaker<Q, MyTypes<Q>[T] & RefMaker<Q, T> & IsMaker<Q, P, R, T> & NoNever<RelationMaker<Q, T, R>>> & IsMaker<Q, P, R, T> & NoNever<RelationMaker<Q, T, R>>;
type NoNever<T extends Record<string, unknown>> = {
    [K in keyof T as T[K] extends never ? never : K]: T[K];
};
type RelationMaker<Q, T extends MyKeys<Q>, R extends string> = {
    relation: R extends `${infer First}${infer Rest}` ? `${Uppercase<First>}${Rest}` extends MyKeys<Q> ? Concept<Q, T, 'relation', `${Uppercase<First>}${Rest}`> : never : never;
};
type WhereArgs<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>> = {
    [K in keyof Q[T] as CircularGuard<K, R, Q[T][K], P>]: MyTypes<Q>[T][K];
} & {
    ref: Ref<Q, T>;
} & IsMaker<Q, P, R, T, true>;
type Concept<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>> = WhereMaker<Q, PureConcept<Q, P, R, T>, WhereArgs<Q, P, R, T>> & PureConcept<Q, P, R, T> & LinkMaker<Q, T, R>;
type NonEmptyArray<T> = [T, T, ...T[]];
type LinkMaker<Q, T extends MyKeys<Q>, R extends string = never> = {
    link(node: PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | OneOrMany<RefValue<Q, T>> | undefined): Promise<number>;
    link(...nodes: NonEmptyArray<PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | OneOrMany<RefValue<Q, T>> | undefined>): Promise<number>;
    link(node: PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | OneOrMany<RefValue<Q, T>> | undefined, relation: R extends `${infer First}${infer Rest}` ? `${Uppercase<First>}${Rest}` extends MyKeys<Q> ? Partial<ConceptValue<Q, `${Uppercase<First>}${Rest}`>> : never : never): R extends `${infer First}${infer Rest}` ? `${Uppercase<First>}${Rest}` extends MyKeys<Q> ? Promise<RefValue<Q, `${Uppercase<First>}${Rest}`>> : never : never;
    update(node: PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | OneOrMany<RefValue<Q, T>> | undefined): Promise<{
        linked: number;
        unlinked: number;
    }>;
    update(...nodes: NonEmptyArray<PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | OneOrMany<RefValue<Q, T>> | undefined>): Promise<{
        linked: number;
        unlinked: number;
    }>;
    unlink(node?: PureConcept<Q, MyKeys<Q>, string, T> | OneOrMany<RefValue<Q, T>> | undefined): Promise<number>;
    unlink(...nodes: NonEmptyArray<PureConcept<Q, MyKeys<Q>, string, T> | OneOrMany<RefValue<Q, T>> | undefined>): Promise<number>;
};
type ContentLinkMaker<Q, T> = {
    link(node: T): Promise<number>;
    link(...node: NonEmptyArray<T>): Promise<number>;
    update(node: T): Promise<{
        linked: number;
        unlinked: number;
    }>;
    update(...node: NonEmptyArray<T>): Promise<{
        linked: number;
        unlinked: number;
    }>;
    unlink(node?: OneOrMany<T> | undefined): Promise<number>;
    unlink(...node: NonEmptyArray<OneOrMany<T> | undefined>): Promise<number>;
    write(contents: T, type?: T extends number ? 'int' | 'float' : T extends string ? 'string' : never): Promise<number>;
};
type CircularGuard<K, R, M, P> = K extends R ? M extends P ? never : K : K;
type IsRelations<Q, T extends MyKeys<Q>, R extends string, P extends MyKeys<Q>, simple extends boolean> = UnionToIntersection<{
    [M in MyKeys<Q>]: {
        [K in keyof Q[M] as Q[M][K] extends T ? CircularGuard<K, R, M, P> : never]: K extends string ? simple extends true ? WhereArgs<Q, T, K, M> : Concept<Q, T, K, M> : never;
    };
}[Exclude<MyKeys<Q>, T>]>;
type IsHelper<Q, T, simple extends boolean> = simple extends true ? T : T & GetMaker<Q, T> & WhereMaker<Q, T>;
type IsMaker<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>, simple extends boolean = false> = keyof {
    [K in keyof IsRelations<Q, T, R, P, simple>]: IsRelations<Q, T, R, P, simple>[K];
} extends never ? unknown : {
    is: IsHelper<Q, {
        [K in keyof IsRelations<Q, T, R, P, simple>]: IsRelations<Q, T, R, P, simple>[K];
    }, simple>;
};
export type Query<Q, M extends MyKeys<Q>> = {
    <I>(args: I & (I extends TemplateStringsArray ? TemplateStringsArray : never)): Concept<Q, never, 'element', M>;
    <I>(args: I & (I extends TemplateStringsArray ? TemplateStringsArray : never), addr: number): RefValue<Q, M>;
    new (): Mutation<Q, M, false>;
    new <I extends ConceptValue<Q, M>>(_: NonExtensible<ConceptValue<Q, M>, I> extends true ? I : ConceptValue<Q, M>): Mutation<Q, M, I extends unknown[] ? true : keyof {
        [K in keyof I as I[K] extends unknown[] ? K : never]: K;
    } extends never ? false : true>;
    /** Element of a concept class */
    element: Concept<Q, never, 'element', M>;
    $(args: TemplateStringsArray): Concept<Q, never, 'element', M>;
    $(args: $And<string[]>): Concept<Q, never, 'element', M>;
};
type IgnoringFields<Q> = 'get' | 'where' | keyof LinkMaker<Q, MyKeys<Q>> | keyof Contents<Q, unknown>;
type DeepWhere<Q, T> = OneOrMany<NonEmpty<{
    [K in keyof T as K extends IgnoringFields<Q> ? never : K]: T[K] extends Contents<Q, infer C> ? $And<OneOrMany<C>> : $And<DeepWhere<Q, T[K]>>;
}>>;
type WhereMaker<Q, T, A = T> = {
    where(_: DeepWhere<Q, A>): T;
};
type RefValue<Q, T extends MyKeys<Q>> = Omit<Concept<Q, MyKeys<Q>, never, T>, 'ref' | 'link' | 'unlink'> & {
    ref: {
        addr: number;
    } & DeleteMaker;
};
type RefMaker<Q, T extends MyKeys<Q> = MyKeys<Q>> = {
    ref: Ref<Q, T> & Contents<Q, RefValue<Q, T>> & DeleteMaker & WhereMaker<Q, Ref<Q, T> & Contents<Q, PureRef<Q, T> & Concept<Q, MyKeys<Q>, string, T>> & DeleteMaker, Ref<Q, T>>;
};
type DeleteMaker = {
    delete(): never;
} & {
    delete: Promise<true>;
};
type PureRef<Q, T extends MyKeys<Q> = MyKeys<Q>> = {
    addr: Contents<Q, number, T>;
};
interface Ref<Q, T extends MyKeys<Q> = MyKeys<Q>> extends PureRef<Q, T>, GetMaker<Q, Ref<Q, T>> {
}
type Contents<Q, T, P extends MyKeys<Q> = MyKeys<Q>> = {
    one(): never;
    many(): never;
} & {
    one: Promise<T | undefined> & {
        reactive(): never;
    } & {
        reactive: Promise<Disposable<Signal<T>>>;
    };
    many: Promise<T[]> & {
        reactive(): never;
    } & {
        reactive: Promise<Disposable<T[]>>;
    };
} & ContentLinkMaker<Q, T>;
type GetMaker<Q, P> = {
    get<T>(_: Cool<T, DeepTrue<Q, P>>): Promise<{
        [K in keyof DeepResult<Q, T, P>]: DeepResult<Q, T, P>[K];
    }[]> & {
        reactive(): never;
    } & {
        reactive: Promise<Disposable<{
            [K in keyof DeepResult<Q, T, P>]: DeepResult<Q, T, P>[K];
        }[]>>;
    };
};
type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
type Cool<Current, Expected> = keyof Current extends never ? Expected : {
    [K in keyof Current]: K extends keyof Expected ? Current[K] extends DeepPartial<Expected[K]> ? Exclude<Expected[K], true | string> extends object ? Cool<Current[K], Exclude<Expected[K], true | string>> : Current[K] : Expected[K] : never;
};
type NonExtensible<A, B> = keyof {
    [k in keyof B as k extends keyof A ? B[k] extends object ? false extends true ? never : k : never : k]: k;
} extends never ? true : false;
type DeepTrue<Q, P> = {
    [K in keyof P as K extends IgnoringFields<Q> ? never : K]: P[K] extends Ref<Q> ? true | DeepTrue<Q, PureRef<P[K]>> | string : P[K] extends Contents<Q, unknown> ? true | string : DeepTrue<Q, P[K]>;
};
type FilterTrues<Q, T, P> = P extends Record<keyof T, unknown> ? {
    [K in keyof T as T[K] extends string ? never : keyof FilterTrues<Q, T[K], P[K]> extends never ? never : K]: T[K] extends object ? FilterTrues<Q, T[K], P[K]> : P[K] extends Contents<Q, infer C> ? C : P[K] extends Ref<Q> ? FilterTrues<Q, Record<keyof PureRef<Q>, true>, PureRef<Q>> : never;
} : never;
type FlattenStrings<Q, T, P> = P extends Record<keyof T, unknown> ? {
    [K in keyof T as T[K] extends string ? T[K] : never]: P[K] extends Contents<Q, infer C> ? C : P[K] extends Ref<Q> ? FilterTrues<Q, Record<keyof PureRef<Q>, true>, PureRef<Q>> : never;
} & UnionToIntersection<{
    [K in keyof T]: T[K] extends object ? FlattenStrings<Q, T[K], P[K]> : never;
}[keyof T]> : never;
type DeepResult<Q, T, P> = P extends Record<keyof T, unknown> ? FlattenStrings<Q, T, P> & FilterTrues<Q, T, P> : never;
type Mutation<Q, T extends MyKeys<Q>, I extends boolean = boolean> = {
    [Symbol.unscopables]: T;
    create(): never;
} & {
    create: Promise<true extends I ? false extends I ? OneOrMany<RefValue<Q, T>> : RefValue<Q, T>[] : RefValue<Q, T> & {
        relations: number[];
    }>;
};
type IsCreation<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>> = UnionToIntersection<{
    [M in MyKeys<Q>]: {
        [K in keyof Q[M] as Q[M][K] extends T ? CircularGuard<K, R, M, P> : never]: CreationConnection<Q, T, K, M>;
    };
}[Exclude<MyKeys<Q>, T>]>;
type CustomRelationConnection<A, CR extends Record<string, unknown>> = keyof NoNever<CR> extends never ? A : A | ({
    value: A;
} & CR);
type CustomRelationCreation<Q, R, T extends MyKeys<Q>> = {
    relation: R extends `${infer First}${infer Rest}` ? `${Uppercase<First>}${Rest}` extends MyKeys<Q> ? CreationValue<Q, T, 'relation', `${Uppercase<First>}${Rest}`> : never : never;
};
type CreationConnection<Q, P, R, T> = R extends string ? T extends MyKeys<Q> ? $And<OneOrMany<CustomRelationConnection<PureConcept<Q, MyKeys<Q>, string, T> | Mutation<Q, T> | RefValue<Q, T>, CustomRelationCreation<Q, R, T>>>> : OneOrMany<T> : never;
type CreationValue<Q, P extends MyKeys<Q>, R extends string, T extends MyKeys<Q>> = OneOrMany<NonEmpty<{
    [K in keyof Q[T]]: CreationConnection<Q, T, K, Q[T][K]>;
} & {
    is: OneOrMany<NonEmpty<{
        [K in keyof IsCreation<Q, P, R, T>]: IsCreation<Q, P, R, T>[K];
    }>>;
}>>;
type ConceptValue<Q, T extends MyKeys<Q> = never> = CreationValue<Q, never, never, T>;
type MyTypes<Q> = {
    [M in MyKeys<Q>]: {
        [K in keyof Q[M]]: Q[M][K] extends MyKeys<Q> ? K extends string ? Concept<Q, M, K, Q[M][K]> : never : Contents<Q, Q[M][K], M>;
    };
};
type MyKeys<Q> = keyof Q;
export type Magic<Q> = {
    [M in MyKeys<Q>]: Query<Q, M>;
};
export {};
