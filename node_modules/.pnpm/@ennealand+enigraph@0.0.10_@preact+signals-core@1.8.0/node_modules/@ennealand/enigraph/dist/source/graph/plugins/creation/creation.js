import { jsx as _jsx } from "preact/jsx-runtime";
import { useComputed } from '@preact/signals';
import { useDeepSignal } from 'deepsignal';
import { useCallback } from 'preact/hooks';
export const withCreation = (props) => {
    const drawingEdges = useDeepSignal({ values: [] });
    const createNode = (x, y, type) => {
        const newNode = { id: 0, type, x, y };
        props.addNode(newNode);
        if (drawingEdges.values.length) {
            for (const { type, source } of drawingEdges.values) {
                props.addEdge({ id: 0, type, source, target: newNode });
            }
            drawingEdges.values = [];
        }
    };
    const startDrawingEdge = (x, y, type) => {
        if (!props.selection)
            return;
        const newValues = [];
        for (const node of props.nodes) {
            if (props.selection.value.has(node.id)) {
                newValues.push({ type, source: node, target: { x, y } });
            }
        }
        drawingEdges.values = newValues;
    };
    const updateDrawingEdges = (e) => {
        if (!props.selection || !drawingEdges.values.length)
            return;
        const [x, y] = props.localize(...props.getInnerPoint(e.clientX, e.clientY));
        for (const edge of drawingEdges.values) {
            edge.target.x = x;
            edge.target.y = y;
        }
    };
    const createEdges = (selection, nodes) => {
        if (drawingEdges.values.length) {
            for (const { type, source } of drawingEdges.values) {
                for (const node of nodes) {
                    if (!selection.has(node.id))
                        continue;
                    props.addEdge({ id: 0, type, source, target: node });
                }
            }
            drawingEdges.values = [];
        }
    };
    const component = useCallback(() => (props.Edge ? _jsx(DrawingEdges, { Edge: props.Edge, edges: drawingEdges.values }) : null), [drawingEdges]);
    const isDrawingEdges = useComputed(() => !!drawingEdges.$values?.value.length);
    return { createNode, startDrawingEdge, updateDrawingEdges, createEdges, DrawingEdges: component, isDrawingEdges };
};
const DrawingEdges = (props) => {
    return (_jsx("g", { children: props.edges.map((edge, index) => (_jsx(props.Edge, { type: edge.type, x1: edge.source.x, y1: edge.source.y, x2: edge.target.x, y2: edge.target.y }, index))) }));
};
