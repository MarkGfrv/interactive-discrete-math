import { useSignal } from '@preact/signals';
import { computed } from '@preact/signals';
import { useCallback, useEffect } from 'preact/hooks';
export const withDraggable = (props) => {
    const dragging = useSignal(false);
    const startPoint = useSignal({ x: 0, y: 0 });
    const totalShift = useSignal({ x: 0, y: 0 });
    const startDragginig = (e) => {
        dragging.value = true;
        const [x, y] = props.getInnerPoint(e.clientX, e.clientY);
        startPoint.value.x = x;
        startPoint.value.y = y;
        totalShift.value.x = 0;
        totalShift.value.y = 0;
        document.addEventListener('mouseup', stopDragging, { once: true });
    };
    const updateDragging = (e) => {
        const [x, y] = props.getInnerPoint(e.clientX, e.clientY);
        const shiftX = startPoint.value.x - x;
        const shiftY = startPoint.value.y - y;
        const zoom = props.zoom?.value ?? 1;
        for (const node of props.nodes) {
            if (!props.selection.value.has(node.id))
                continue;
            props.changeNodePosition?.(node, node.x - shiftX / zoom, node.y - shiftY / zoom);
        }
        totalShift.value.x += shiftX;
        totalShift.value.y += shiftY;
        startPoint.value.x = x;
        startPoint.value.y = y;
    };
    const abortDragging = (options) => {
        if (!dragging.value)
            return;
        if (options?.revert) {
            const zoom = props.zoom?.value ?? 1;
            for (const node of props.nodes) {
                if (!props.selection.value.has(node.id))
                    continue;
                props.changeNodePosition?.(node, node.x + totalShift.value.x / zoom, node.y + totalShift.value.y / zoom);
            }
        }
        stopDragging();
    };
    const stopDragging = useCallback(() => {
        document.removeEventListener('mouseup', stopDragging);
        if (props.nodePositionChanged) {
            for (const node of props.nodes) {
                if (!props.selection.value.has(node.id))
                    continue;
                props.nodePositionChanged(node);
            }
        }
        dragging.value = false;
    }, [dragging, props.nodes, props.selection, props.nodePositionChanged]);
    useEffect(() => () => document.removeEventListener('mouseup', stopDragging), [dragging, props.nodes, props.selection, props.nodePositionChanged]);
    return { isDragging: computed(() => dragging.value), startDragginig, updateDragging, abortDragging };
};
