{
  "version": 3,
  "sources": ["../../.pnpm/deepsignal@1.5.0_@preact+signals-core@1.8.0_@preact+signals@1.2.3_preact@10.20.1__preact@10.20.1/node_modules/deepsignal/core/src/index.ts", "../../.pnpm/deepsignal@1.5.0_@preact+signals-core@1.8.0_@preact+signals@1.2.3_preact@10.20.1__preact@10.20.1/node_modules/deepsignal/src/index.ts"],
  "sourcesContent": ["import { computed, signal, Signal } from \"@preact/signals-core\";\n\nconst proxyToSignals = new WeakMap();\nconst objToProxy = new WeakMap();\nconst arrayToArrayOfSignals = new WeakMap();\nconst ignore = new WeakSet();\nconst objToIterable = new WeakMap();\nconst rg = /^\\$/;\nconst descriptor = Object.getOwnPropertyDescriptor;\nlet peeking = false;\n\nexport const deepSignal = <T extends object>(obj: T): DeepSignal<T> => {\n\tif (!shouldProxy(obj)) throw new Error(\"This object can't be observed.\");\n\tif (!objToProxy.has(obj))\n\t\tobjToProxy.set(obj, createProxy(obj, objectHandlers) as DeepSignal<T>);\n\treturn objToProxy.get(obj);\n};\n\nexport const peek = <\n\tT extends DeepSignalObject<object>,\n\tK extends keyof RevertDeepSignalObject<T>\n>(\n\tobj: T,\n\tkey: K\n): RevertDeepSignal<RevertDeepSignalObject<T>[K]> => {\n\tpeeking = true;\n\tconst value = obj[key];\n\ttry {\n\t\tpeeking = false;\n\t} catch (e) {}\n\treturn value as RevertDeepSignal<RevertDeepSignalObject<T>[K]>;\n};\n\nconst isShallow = Symbol(\"shallow\");\nexport function shallow<T extends object>(obj: T): Shallow<T> {\n\tignore.add(obj);\n\treturn obj as Shallow<T>;\n}\n\nconst createProxy = (target: object, handlers: ProxyHandler<object>) => {\n\tconst proxy = new Proxy(target, handlers);\n\tignore.add(proxy);\n\treturn proxy;\n};\n\nconst throwOnMutation = () => {\n\tthrow new Error(\"Don't mutate the signals directly.\");\n};\n\nconst get =\n\t(isArrayOfSignals: boolean) =>\n\t(target: object, fullKey: string, receiver: object): unknown => {\n\t\tif (peeking) return Reflect.get(target, fullKey, receiver);\n\t\tlet returnSignal = isArrayOfSignals || fullKey[0] === \"$\";\n\t\tif (!isArrayOfSignals && returnSignal && Array.isArray(target)) {\n\t\t\tif (fullKey === \"$\") {\n\t\t\t\tif (!arrayToArrayOfSignals.has(target))\n\t\t\t\t\tarrayToArrayOfSignals.set(target, createProxy(target, arrayHandlers));\n\t\t\t\treturn arrayToArrayOfSignals.get(target);\n\t\t\t}\n\t\t\treturnSignal = fullKey === \"$length\";\n\t\t}\n\t\tif (!proxyToSignals.has(receiver)) proxyToSignals.set(receiver, new Map());\n\t\tconst signals = proxyToSignals.get(receiver);\n\t\tconst key = returnSignal ? fullKey.replace(rg, \"\") : fullKey;\n\t\tif (\n\t\t\t!signals.has(key) &&\n\t\t\ttypeof descriptor(target, key)?.get === \"function\"\n\t\t) {\n\t\t\tsignals.set(\n\t\t\t\tkey,\n\t\t\t\tcomputed(() => Reflect.get(target, key, receiver))\n\t\t\t);\n\t\t} else {\n\t\t\tlet value = Reflect.get(target, key, receiver);\n\t\t\tif (returnSignal && typeof value === \"function\") return;\n\t\t\tif (typeof key === \"symbol\" && wellKnownSymbols.has(key)) return value;\n\t\t\tif (!signals.has(key)) {\n\t\t\t\tif (shouldProxy(value)) {\n\t\t\t\t\tif (!objToProxy.has(value))\n\t\t\t\t\t\tobjToProxy.set(value, createProxy(value, objectHandlers));\n\t\t\t\t\tvalue = objToProxy.get(value);\n\t\t\t\t}\n\t\t\t\tsignals.set(key, signal(value));\n\t\t\t}\n\t\t}\n\t\treturn returnSignal ? signals.get(key) : signals.get(key).value;\n\t};\n\nconst objectHandlers = {\n\tget: get(false),\n\tset(target: object, fullKey: string, val: any, receiver: object): boolean {\n\t\tif (typeof descriptor(target, fullKey)?.set === \"function\")\n\t\t\treturn Reflect.set(target, fullKey, val, receiver);\n\t\tif (!proxyToSignals.has(receiver)) proxyToSignals.set(receiver, new Map());\n\t\tconst signals = proxyToSignals.get(receiver);\n\t\tif (fullKey[0] === \"$\") {\n\t\t\tif (!(val instanceof Signal)) throwOnMutation();\n\t\t\tconst key = fullKey.replace(rg, \"\");\n\t\t\tsignals.set(key, val);\n\t\t\treturn Reflect.set(target, key, val.peek(), receiver);\n\t\t} else {\n\t\t\tlet internal = val;\n\t\t\tif (shouldProxy(val)) {\n\t\t\t\tif (!objToProxy.has(val))\n\t\t\t\t\tobjToProxy.set(val, createProxy(val, objectHandlers));\n\t\t\t\tinternal = objToProxy.get(val);\n\t\t\t}\n\t\t\tconst isNew = !(fullKey in target);\n\t\t\tconst result = Reflect.set(target, fullKey, val, receiver);\n\t\t\tif (!signals.has(fullKey)) signals.set(fullKey, signal(internal));\n\t\t\telse signals.get(fullKey).value = internal;\n\t\t\tif (isNew && objToIterable.has(target)) objToIterable.get(target).value++;\n\t\t\tif (Array.isArray(target) && signals.has(\"length\"))\n\t\t\t\tsignals.get(\"length\").value = target.length;\n\t\t\treturn result;\n\t\t}\n\t},\n\tdeleteProperty(target: object, key: string): boolean {\n\t\tif (key[0] === \"$\") throwOnMutation();\n\t\tconst signals = proxyToSignals.get(objToProxy.get(target));\n\t\tconst result = Reflect.deleteProperty(target, key);\n\t\tif (signals && signals.has(key)) signals.get(key).value = undefined;\n\t\tobjToIterable.has(target) && objToIterable.get(target).value++;\n\t\treturn result;\n\t},\n\townKeys(target: object): (string | symbol)[] {\n\t\tif (!objToIterable.has(target)) objToIterable.set(target, signal(0));\n\t\t(objToIterable as any)._ = objToIterable.get(target).value;\n\t\treturn Reflect.ownKeys(target);\n\t},\n};\n\nconst arrayHandlers = {\n\tget: get(true),\n\tset: throwOnMutation,\n\tdeleteProperty: throwOnMutation,\n};\n\nconst wellKnownSymbols = new Set(\n\tObject.getOwnPropertyNames(Symbol)\n\t\t.map(key => Symbol[key as WellKnownSymbols])\n\t\t.filter(value => typeof value === \"symbol\")\n);\nconst supported = new Set([Object, Array]);\nconst shouldProxy = (val: any): boolean => {\n\tif (typeof val !== \"object\" || val === null) return false;\n\treturn supported.has(val.constructor) && !ignore.has(val);\n};\n\n/** TYPES **/\n\nexport type DeepSignal<T> = T extends Function\n\t? T\n\t: T extends { [isShallow]: true }\n\t? T\n\t: T extends Array<unknown>\n\t? DeepSignalArray<T>\n\t: T extends object\n\t? DeepSignalObject<T>\n\t: T;\n\ntype DeepSignalObject<T extends object> = {\n\t[P in keyof T & string as `$${P}`]?: T[P] extends Function\n\t\t? never\n\t\t: Signal<T[P]>;\n} & {\n\t[P in keyof T]: DeepSignal<T[P]>;\n};\n\n/** @ts-expect-error **/\ninterface DeepArray<T> extends Array<T> {\n\tmap: <U>(\n\t\tcallbackfn: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tthisArg?: any\n\t) => U[];\n\tforEach: (\n\t\tcallbackfn: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => void,\n\t\tthisArg?: any\n\t) => void;\n\tconcat(...items: ConcatArray<T>[]): DeepSignalArray<T[]>;\n\tconcat(...items: (T | ConcatArray<T>)[]): DeepSignalArray<T[]>;\n\treverse(): DeepSignalArray<T[]>;\n\tshift(): DeepSignal<T> | undefined;\n\tslice(start?: number, end?: number): DeepSignalArray<T[]>;\n\tsplice(start: number, deleteCount?: number): DeepSignalArray<T[]>;\n\tsplice(\n\t\tstart: number,\n\t\tdeleteCount: number,\n\t\t...items: T[]\n\t): DeepSignalArray<T[]>;\n\tfilter<S extends T>(\n\t\tpredicate: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => value is DeepSignal<S>,\n\t\tthisArg?: any\n\t): DeepSignalArray<S[]>;\n\tfilter(\n\t\tpredicate: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => unknown,\n\t\tthisArg?: any\n\t): DeepSignalArray<T[]>;\n\treduce(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => T\n\t): DeepSignal<T>;\n\treduce(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => DeepSignal<T>,\n\t\tinitialValue: T\n\t): DeepSignal<T>;\n\treduce<U>(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: U,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tinitialValue: U\n\t): U;\n\treduceRight(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => T\n\t): DeepSignal<T>;\n\treduceRight(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => DeepSignal<T>,\n\t\tinitialValue: T\n\t): DeepSignal<T>;\n\treduceRight<U>(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: U,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tinitialValue: U\n\t): U;\n}\ntype ArrayType<T> = T extends Array<infer I> ? I : T;\ntype DeepSignalArray<T> = DeepArray<ArrayType<T>> & {\n\t[key: number]: DeepSignal<ArrayType<T>>;\n\t$?: { [key: number]: Signal<ArrayType<T>> };\n\t$length?: Signal<number>;\n};\n\nexport type Shallow<T extends object> = T & { [isShallow]: true };\n\nexport declare const useDeepSignal: <T extends object>(obj: T) => DeepSignal<T>;\n\ntype FilterSignals<K> = K extends `$${infer P}` ? never : K;\ntype RevertDeepSignalObject<T> = Pick<T, FilterSignals<keyof T>>;\ntype RevertDeepSignalArray<T> = Omit<T, \"$\" | \"$length\">;\n\nexport type RevertDeepSignal<T> = T extends Array<unknown>\n\t? RevertDeepSignalArray<T>\n\t: T extends object\n\t? RevertDeepSignalObject<T>\n\t: T;\n\ntype WellKnownSymbols =\n\t| \"asyncIterator\"\n\t| \"hasInstance\"\n\t| \"isConcatSpreadable\"\n\t| \"iterator\"\n\t| \"match\"\n\t| \"matchAll\"\n\t| \"replace\"\n\t| \"search\"\n\t| \"species\"\n\t| \"split\"\n\t| \"toPrimitive\"\n\t| \"toStringTag\"\n\t| \"unscopables\";\n", "import \"@preact/signals\";\nimport { useMemo } from \"preact/hooks\";\nimport { deepSignal, type DeepSignal } from \"../core/src\";\n\nexport const useDeepSignal = <T extends object>(obj: T): DeepSignal<T> => {\n\treturn useMemo(() => deepSignal(obj), []);\n};\n\nexport * from \"../core/src\";\n"],
  "mappings": "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",
  "names": ["proxyToSignals", "WeakMap", "objToProxy", "arrayToArrayOfSignals", "ignore", "WeakSet", "objToIterable", "rg", "descriptor", "Object", "getOwnPropertyDescriptor", "peeking", "deepSignal", "obj", "shouldProxy", "Error", "has", "set", "createProxy", "objectHandlers", "get", "peek", "key", "value", "e", "add", "target", "handlers", "proxy", "Proxy", "throwOnMutation", "isArrayOfSignals", "fullKey", "receiver", "_descriptor", "Reflect", "returnSignal", "Array", "isArray", "arrayHandlers", "Map", "signals", "replace", "wellKnownSymbols", "signal", "computed", "val", "_descriptor2", "Signal", "internal", "isNew", "result", "length", "deleteProperty", "ownKeys", "_", "Set", "getOwnPropertyNames", "Symbol", "map", "filter", "supported", "constructor", "useDeepSignal", "useMemo"]
}
