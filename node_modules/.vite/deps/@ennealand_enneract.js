import {
  g
} from "./chunk-ZEHCN5TK.js";
import {
  E,
  d,
  n,
  r,
  u,
  w
} from "./chunk-O7WJARF6.js";
import "./chunk-C32UJPNP.js";
import "./chunk-HD5T2LL3.js";
import {
  __publicField
} from "./chunk-TYRVL62N.js";

// node_modules/.pnpm/@ennealand+enneract@0.8.4-test_@preact+signals-core@1.8.0_preact@10.20.1/node_modules/@ennealand/enneract/dist/mod.js
var Ce = Object.defineProperty;
var Ee = (l, e) => {
  for (var t in e)
    Ce(l, t, { get: e[t], enumerable: true });
};
var N = {};
Ee(N, { SupportedContetTypes: () => Re });
var Re = ["int", "float", "string", "binary"];
var S = class extends ReferenceError {
  constructor() {
    super("Cannot perform operation when connection is closed.");
  }
};
var G = class {
  constructor(e, t) {
    __publicField(this, "ws");
    __publicField(this, "resolveHealthcheck");
    __publicField(this, "queue", /* @__PURE__ */ new Map());
    __publicField(this, "eventsQueue", /* @__PURE__ */ new Map());
    __publicField(this, "messageCounter", 0);
    __publicField(this, "connected");
    __publicField(this, "closed");
    __publicField(this, "keynodes", /* @__PURE__ */ new Map());
    __publicField(this, "hangingOperations", /* @__PURE__ */ new Set());
    __publicField(this, "healthCheckInterval");
    __publicField(this, "onMessage", (e) => {
      var _a2;
      if (e.data === '"OK"' || e.data === '"NO"') {
        (_a2 = this.resolveHealthcheck) == null ? void 0 : _a2.call(this, e.data === '"OK"');
        return;
      }
      let { id: t, event: s, payload: r2, errors: n2 } = JSON.parse(e.data);
      if (s) {
        let i = this.eventsQueue.get(t);
        i && i(r2);
        return;
      }
      let a = this.queue.get(t);
      a && (this.queue.delete(t), (n2 == null ? void 0 : n2.length) && console.log(`%c${n2}`, "color:red"), a(r2));
    });
    this.url = e;
    this.options = t;
    this.connect();
  }
  connect() {
    this.ws = new WebSocket(this.url), this.ws.onmessage = this.onMessage, this.connected = new Promise((e) => {
      this.ws.onopen = (t) => {
        this.onConnect(t), e(true);
      };
    }), this.closed = new Promise((e) => {
      this.ws.onclose = (t) => {
        this.onDisconnect(t), e(true);
      };
    });
  }
  onConnect(e) {
    console.log("Enneract: connection opened"), clearInterval(this.healthCheckInterval), this.healthCheckInterval = setInterval(async () => {
      await this.send("healthcheck", null) || console.warn("Sc-machine is not healthy");
    }, 12e4);
  }
  onDisconnect(e) {
    var _a2;
    console.log(`Enneract: connection closed (${e.reason})`), ((_a2 = this.options) == null ? void 0 : _a2.reconnect) && new Promise((t) => setTimeout(t, 1e3)).then(() => {
      this.connect();
    });
  }
  async subscribe(e, t) {
    let s = await this.send("events", { create: e });
    for (let [r2, n2] of s.entries())
      this.eventsQueue.set(n2, t.bind(null, r2));
    return s;
  }
  async unsubscribe(e) {
    let t = this.send("events", { delete: e });
    this.hangingOperations.add(t);
    for (let s of e)
      this.eventsQueue.delete(s);
    return await t.then((s) => (this.hangingOperations.delete(t), s));
  }
  async send(e, t) {
    if (await this.connected, this.ws.readyState !== this.ws.OPEN)
      throw new S();
    return this.messageCounter++, this.ws.send(JSON.stringify({ type: e.split(":")[0], payload: t, id: this.messageCounter })), e === "healthcheck" ? new Promise((s) => this.resolveHealthcheck = s) : new Promise((s) => this.queue.set(this.messageCounter, s));
  }
  async getKeynode(e) {
    let t = this.keynodes.get(e);
    try {
      if (t || (t = this.send("keynodes", [{ command: "find", idtf: e }]).then(([s]) => s), this.keynodes.set(e, t)), !await t)
        throw new TypeError(`Keynode '${e}' does not exist`);
      return await t;
    } catch (s) {
      throw s;
    }
  }
  async disconnect() {
    if (this.hangingOperations.size && (console.log("%cWaiting for hanging operations to complete...", "color: grey"), await Promise.allSettled(this.hangingOperations)), this.eventsQueue.size) {
      let e = Array.from(this.eventsQueue.keys());
      console.log(`%cCleaning up all hanging agents (${e.join(", ")})`, "color: grey"), await this.unsubscribe(e);
    }
    this.ws.close(1e3, "disconnect"), await this.closed;
  }
};
var v = 1;
var ee = 3;
var Q = 16388;
var B = 49160;
var M = 49168;
var E2 = 32;
var R = 64;
var z = 49296;
var U = 49424;
var K = 49680;
var L = 50192;
var W = 51216;
var te = 128;
var ne = 256;
var se = 512;
var re = 1024;
var ie = 2048;
var ae = 4096;
var oe = 8192;
var k = ((o) => (o[o.EdgeUCommon = Q] = "EdgeUCommon", o[o.EdgeDCommon = B] = "EdgeDCommon", o[o.EdgeUCommonConst = Q | E2] = "EdgeUCommonConst", o[o.EdgeDCommonConst = B | E2] = "EdgeDCommonConst", o[o.EdgeUCommonVar = Q | R] = "EdgeUCommonVar", o[o.EdgeDCommonVar = B | R] = "EdgeDCommonVar", o[o.EdgeAccess = M] = "EdgeAccess", o[o.EdgeAccessConstPosPerm = E2 | M | W | z] = "EdgeAccessConstPosPerm", o[o.EdgeAccessConstNegPerm = E2 | M | W | U] = "EdgeAccessConstNegPerm", o[o.EdgeAccessConstFuzPerm = E2 | M | K] = "EdgeAccessConstFuzPerm", o[o.EdgeAccessConstPosTemp = E2 | M | L | z] = "EdgeAccessConstPosTemp", o[o.EdgeAccessConstNegTemp = E2 | M | L | U] = "EdgeAccessConstNegTemp", o[o.EdgeAccessConstFuzTemp = E2 | M | K] = "EdgeAccessConstFuzTemp", o[o.EdgeAccessVarPosPerm = R | M | W | z] = "EdgeAccessVarPosPerm", o[o.EdgeAccessVarNegPerm = R | M | W | U] = "EdgeAccessVarNegPerm", o[o.EdgeAccessVarFuzPerm = R | M | K] = "EdgeAccessVarFuzPerm", o[o.EdgeAccessVarPosTemp = R | M | L | z] = "EdgeAccessVarPosTemp", o[o.EdgeAccessVarNegTemp = R | M | L | U] = "EdgeAccessVarNegTemp", o[o.EdgeAccessVarFuzTemp = R | M | K] = "EdgeAccessVarFuzTemp", o[o.Const = E2] = "Const", o[o.Var = R] = "Var", o[o.Node = v] = "Node", o[o.Link = ee] = "Link", o[o.Unknown = 0] = "Unknown", o[o.NodeConst = v | E2] = "NodeConst", o[o.NodeVar = v | R] = "NodeVar", o[o.LinkConst = ee | E2] = "LinkConst", o[o.LinkVar = ee | R] = "LinkVar", o[o.NodeStruct = v | ne] = "NodeStruct", o[o.NodeTuple = v | te] = "NodeTuple", o[o.NodeRole = v | se] = "NodeRole", o[o.NodeNoRole = v | re] = "NodeNoRole", o[o.NodeClass = v | ie] = "NodeClass", o[o.NodeAbstract = v | ae] = "NodeAbstract", o[o.NodeMaterial = v | oe] = "NodeMaterial", o[o.NodeConstStruct = v | E2 | ne] = "NodeConstStruct", o[o.NodeConstTuple = v | E2 | te] = "NodeConstTuple", o[o.NodeConstRole = v | E2 | se] = "NodeConstRole", o[o.NodeConstNoRole = v | E2 | re] = "NodeConstNoRole", o[o.NodeConstClass = v | E2 | ie] = "NodeConstClass", o[o.NodeConstAbstract = v | E2 | ae] = "NodeConstAbstract", o[o.NodeConstMaterial = v | E2 | oe] = "NodeConstMaterial", o[o.NodeVarStruct = v | R | ne] = "NodeVarStruct", o[o.NodeVarTuple = v | R | te] = "NodeVarTuple", o[o.NodeVarRole = v | R | se] = "NodeVarRole", o[o.NodeVarNoRole = v | R | re] = "NodeVarNoRole", o[o.NodeVarClass = v | R | ie] = "NodeVarClass", o[o.NodeVarAbstract = v | R | ae] = "NodeVarAbstract", o[o.NodeVarMaterial = v | R | oe] = "NodeVarMaterial", o[o._Edge = Q | B | M] = "_Edge", o))(k || {});
var ke = () => ({ template: [], pre_template: [], buffer: [], bufferCurrent: "", bufferBranches: /* @__PURE__ */ new Map(), current: "", index: 0, initial: "", branches: /* @__PURE__ */ new Map(), filteringTree: [], contentStack: /* @__PURE__ */ new Map(), contentAliases: /* @__PURE__ */ new Set(), addrFindValues: [], isDollar: false, isReverse: false, innerHats: [], linksToFill: {}, globalAliases: {}, aliasItems: /* @__PURE__ */ new Map(), edgeData: /* @__PURE__ */ new Map(), relations: [], getQuery: [] });
var _a;
var O = (_a = class {
  static [Symbol.hasInstance](e) {
    return Object.hasOwn(e, _a.isInstanceFlag);
  }
}, __publicField(_a, "isInstanceFlag", Symbol()), _a);
var D = (l = true) => l ? new Function() : {};
var P = (l = ke(), e = true) => {
  let t = D(e);
  return Object.defineProperties(t, { ...Object.fromEntries(Object.entries(l).map(([s, r2]) => [s, { value: r2, writable: true }])), [O.isInstanceFlag]: { value: true }, resolveBuffer: { value() {
    this.buffer.length && (this.template.push(...this.buffer), this.buffer = [], this.isReverse = false), this.bufferCurrent && (this.current = this.bufferCurrent, this.bufferCurrent = "");
  } }, createPushTemplateItem: { value(s, r2, n2, a) {
    return this.resolveBuffer(), this.bufferBranches.set(r2, { property: n2, relationAlias: a }), (i) => {
      this[s].push(i);
    };
  } }, clone: { get() {
    return P({ template: [...this.template], pre_template: [...this.pre_template], buffer: [...this.buffer], bufferCurrent: this.bufferCurrent, bufferBranches: new Map(this.bufferBranches), current: this.current, index: this.index, initial: this.initial, branches: new Map(this.branches), filteringTree: [...this.filteringTree], contentStack: new Map(this.contentStack), contentAliases: new Set(this.contentAliases), addrFindValues: [...this.addrFindValues], isDollar: this.isDollar, isReverse: this.isReverse, innerHats: [...this.innerHats], linksToFill: { ...this.linksToFill }, globalAliases: { ...this.globalAliases }, aliasItems: new Map(Array.from(this.aliasItems).map(([s, r2]) => [s, r2])), edgeData: new Map(this.edgeData), relations: [...this.relations], getQuery: [...this.getQuery] });
  } }, currentItem: { get() {
    let s = this.bufferCurrent || this.current, r2 = this.current && this.aliasItems.get(this.current);
    return s === "_" ? (this.dynamicRoot || (this.dynamicRoot = { type: "alias", value: s }), this.dynamicRoot) : (r2 && r2.value === 0 && (r2.value = k.Var), typeof s == "string" ? { type: "alias", value: s } : { type: "addr", value: s });
  } } }), t;
};
var de = (l, e, t) => {
  if (t[_]) {
    if (l[e][_] === t[_])
      return;
    l[e] = t;
    return;
  }
  fe(l[e], t);
};
var fe = (l, e) => {
  if (typeof e != "object" || e === null) {
    l.value = e;
    return;
  }
  if (Array.isArray(e)) {
    e.forEach((t, s) => {
      s in l ? typeof t != "object" || t === null ? l[s] !== t && (l[s] = t) : de(l, s, t) : l.push(t);
    }), l.length > e.length && l.splice(e.length);
    return;
  }
  for (let t in l)
    typeof l[t] == "object" && t in e ? de(l, t, e[t]) : t in e && l[t] !== e[t] && (l[t] = e[t]);
  for (let t in e)
    t in l || (l[t] = e[t]);
};
var pe = (l, e) => {
  r(() => fe(e, l));
};
var le = /* @__PURE__ */ new Map();
var me = async (l, e, t, s) => {
  let r2 = le.get(e);
  r2 || le.set(e, r2 = /* @__PURE__ */ new Map());
  let n2 = r2.get(t);
  if (!n2) {
    r2.set(t, n2 = { id: 0, listeners: /* @__PURE__ */ new Set() });
    let [a] = await l.subscribe([{ addr: e, type: t }], () => n2.listeners.forEach((i) => i()));
    n2.id = a;
  }
  return n2.listeners.add(s), async () => {
    n2.listeners.delete(s), n2.listeners.size || (r2.delete(t), await l.unsubscribe([n2.id])), r2.size || le.delete(e);
  };
};
var j = /* @__PURE__ */ new WeakMap();
var ce = /* @__PURE__ */ new WeakMap();
var Te = (l) => {
  for (let e of l)
    j.set(e, (j.get(e) ?? 0) + 1);
};
var he = (l) => {
  for (let e of l) {
    let t = j.get(e);
    if (t > 1)
      j.set(e, t - 1);
    else {
      j.delete(e);
      let s = ce.get(e);
      if (s)
        for (let r2 of s)
          r2();
    }
  }
};
var He = (l, e) => {
  Te(e);
  let t = l();
  return t instanceof Promise ? t.then((s) => (he(e), s)) : (he(e), t);
};
var ye = async (l, e, t, s) => {
  e.exposeResponse = true;
  let r2 = await t, n2 = typeof r2 == "object" && !r2[_] ? g(r2) : d(r2);
  return Ie(l, n2, e, s), n2;
};
var Ie = async (l, e, t, s) => {
  let r2 = false, n2 = false, a = async () => {
    if (r2) {
      n2 = true;
      return;
    }
    if (r2 = true, j.get(e)) {
      let c = ce.get(e);
      c || ce.set(e, c = []), c.push(a), r2 = false;
    } else {
      let c = await s();
      pe(c, e), r2 = false, n2 && (n2 = false, await a());
    }
  }, i = $e(l, t, a);
  await i && Object.defineProperties(e, { [Symbol.dispose]: { enumerable: false, configurable: true, value: () => {
    i.then((c) => c()), console.debug("%cSynchronously cleaned up agents", "color: grey");
  } }, [Symbol.asyncDispose]: { enumerable: false, configurable: true, value: async () => {
    await (await i)(), console.debug("%cAsynchronously cleaned up agents", "color: grey");
  } } });
};
var $e = async (l, e, t) => {
  if (!e.exposedResponse)
    return;
  let s = [];
  for (let r2 of e.template)
    if (r2[0].type === "addr") {
      let n2 = await r2[0].value;
      s.push(me(l, n2, "add_outgoing_edge", t)), s.push(me(l, n2, "remove_outgoing_edge", t));
    }
  return console.debug(`%cCreated new agents (${s.length})`, "color: grey"), await Promise.all(s).then((r2) => () => (console.debug(`%cAsynchronously cleaned up agents (${r2.length})`, "color: grey"), Promise.all(r2.map((n2) => n2()))));
};
var $ = async (l, e, t, s) => await ye(l, e, t, s);
var Z = Symbol();
var Fe = (...l) => ({ [Z]: l });
var ge = (l) => Z in l;
async function ue(l) {
  let e = [];
  for (let { searchTarget: t, current: s, key: r2, isReverse: n2, customRelation: a, dynamicRoot: i, insertPosition: c } of l.innerHats) {
    if (r2 === "sc")
      continue;
    let d2 = t[_] ? [t[_]] : await this.many(t[T], { addr: true });
    l.current = s, l.isReverse = n2, typeof i == "number" && (l.current = e[i], l.relations.push(e[i]));
    for (let u2 of d2) {
      if (r2 === "from" || r2 === "to") {
        let g2 = l.edgeData.get(s);
        g2 ? g2[r2 === "from" ? 0 : 2] = { type: "addr", value: u2 } : l.edgeData.set(s, [{ type: "addr", value: u2 }, l.aliasItems.get(s), { type: "addr", value: u2 }]), e.push("");
        continue;
      }
      if (a && i && c !== void 0) {
        let g2 = l.template.splice(c), h = this.addTemplateEntry(l, r2, { type: "addr", value: u2 }), p = l.bufferBranches.get(h).relationAlias;
        e.push(p), i.value = p, l.resolveBuffer(), l.template.push(...g2), l.relations.push(p);
      } else {
        let g2 = this.addTemplateEntry(l, r2, { type: "addr", value: u2 }), h = l.bufferBranches.get(g2).relationAlias;
        e.push(h);
      }
    }
  }
  l.template.unshift(...l.edgeData.values()), l.template.unshift(...l.pre_template), l.pre_template = [];
}
async function be(l, e, t) {
  let s = await this.transformPromiseTemplate(l);
  if (!s)
    throw new Error("Failed to generate template");
  let r2 = await this.engine.send("generate_template", { templ: s }), n2 = Object.entries(l.linksToFill);
  n2.length && await this.engine.send("content:set", n2.map(([c, { data: d2, type: u2 }]) => ({ command: "set", addr: r2.addrs[r2.aliases[c]], type: u2, data: d2 })));
  let a = e.map((c) => {
    let d2 = r2.addrs[r2.aliases[c]];
    if (!d2)
      return;
    let u2 = P(void 0, false);
    return u2.current = d2, u2.relations = l.relations.map((g2) => r2.addrs[r2.aliases[g2]]), this.generate(u2, d2);
  });
  return Array.isArray(t) || Object.values(t).some((c) => Array.isArray(c)) ? a : a[0];
}
var q = Symbol();
var T = Symbol();
var _ = Symbol();
var J = (l, e) => {
  let t = N.SupportedContetTypes.join(", ");
  if (e !== void 0 && !N.SupportedContetTypes.includes(e))
    throw new TypeError(`Invalid content type passed. Expected one of (${t}) but got '${e}'`);
  if (typeof l != "string" && typeof l != "number")
    throw new TypeError(`Invalid type of content passed. Expected one of (${t}) but got ${typeof l}`);
  if ((e === "int" || e === "float") && typeof l != "number")
    throw new TypeError(`Invalid type of content passed. Expected ${e} but got ${typeof l}`);
  if (e === "string" && typeof l != "string")
    throw new TypeError(`Invalid type of content passed. Expected ${e} but got ${typeof l}`);
};
var X = class {
  constructor(e) {
    __publicField(this, "addTemplateEntry", (e, t, s, r2 = 0, n2 = "template") => {
      let a = e.bufferCurrent || e.current;
      if (t === "is")
        return e.isReverse = true, a;
      let i = (a instanceof Promise ? a.idtf : a) + r2, c = e.branches.get(`${i}.${+e.isReverse}.${t}`);
      if (c)
        return e.isReverse && n2 === "template" && (e.isReverse = false), c;
      e.index++, s.type !== "alias" ? (c = `_v${e.index}`, s.alias = c, e.aliasItems.set(c, s)) : c = s.value, e.branches.set(`${i}.${+e.isReverse}.${t}`, c);
      let [d2, u2] = e.isReverse ? [s, e.currentItem] : [e.currentItem, s];
      e.isReverse && n2 === "template" && (e.isReverse = false);
      let g2 = `_e${e.index}`, h = e.createPushTemplateItem(n2, c, t, g2);
      if (t === "from" || t === "to") {
        let p = `_a${e.index}`;
        t === "from" ? (e.branches.set(`${i}.${+e.isReverse}.to`, p), h([u2, d2, { type: "type", value: 0, alias: p }])) : (e.branches.set(`${i}.${+e.isReverse}.from`, p), h([{ type: "type", value: 0, alias: p }, d2, u2]));
      } else if (t === "element")
        h([d2, { type: "type", value: k.EdgeAccessVarPosPerm, alias: g2 }, u2]);
      else if (/^element[A-Z0-9_]/.test(t)) {
        let p = `rrel${t.slice(7).replace(/[A-Z]+/g, (m) => `_${m.toLowerCase()}`)}`;
        h([d2, { type: "type", value: k.EdgeAccessVarPosPerm, alias: g2 }, u2]), h([{ type: "addr", value: this.engine.getKeynode(p) }, { type: "type", value: k.EdgeAccessVarPosPerm }, { type: "alias", value: g2 }]);
      } else {
        t === "name" && u2.type === "type" && (u2.value = k.LinkVar), h([d2, { type: "type", value: k.EdgeDCommonVar, alias: g2 }, u2]);
        let p = this.engine.getKeynode(`nrel_${t === "name" ? "main_idtf" : t.replace(/[A-Z]+/g, (m) => `_${m.toLowerCase()}`)}`);
        p.idtf = `nrel_${t === "name" ? "main_idtf" : t.replace(/[A-Z]+/g, (m) => `_${m.toLowerCase()}`)}`, h([{ type: "addr", value: p }, { type: "type", value: k.EdgeAccessVarPosPerm }, { type: "alias", value: g2 }]);
      }
      return c;
    });
    __publicField(this, "isObjectOrTrue", (e) => e !== true || typeof e != "object");
    __publicField(this, "processWhereQuery", (e, t) => {
    });
    __publicField(this, "processWhere", (e, t, s) => {
      let r2 = [], n2 = typeof t.alias == "string" && t.alias.startsWith("%") && t.alias;
      if (n2) {
        if (e.globalAliases[n2])
          throw new Error("Alias already defined");
        e.globalAliases[n2] = e.current;
      }
      for (let [a, [i, c]] of Object.entries(t).entries()) {
        if (c == null)
          continue;
        if (i === "sc") {
          let m = e.aliasItems.get(e.bufferCurrent || e.current);
          m.value = c;
          continue;
        }
        let d2 = typeof c == "string" && c.startsWith("%");
        if (i === "alias")
          continue;
        if (d2 && !e.globalAliases[c])
          throw new Error("Alias cannot be referenced before its declaration");
        let u2 = d2 ? { type: "alias", value: e.globalAliases[c] } : e.globalAliases[t.alias] ? { type: "type", value: 0, alias: e.globalAliases[t.alias] } : { type: "type", value: 0 }, g2 = this.addTemplateEntry(e, i, u2);
        s && s.add(g2);
        let h = (m, f) => {
          let y = e.current;
          e.current = g2;
          let x = this.processWhere(e, m, f ?? s);
          return e.current = y, x;
        }, p = (m) => {
          let f = e.contentStack.get(m);
          return f || e.contentStack.set(m, f = { content: m }), f;
        };
        if (typeof c != "object") {
          r2.push({ type: "or", v: g2, values: [p(c)] });
          continue;
        }
        if (Array.isArray(c)) {
          let m = [];
          for (let f of c) {
            if (typeof f != "object") {
              m.push(p(f));
              continue;
            }
            m.push({ type: "and", values: h(f) });
          }
          r2.push({ type: "or", v: g2, values: m });
          continue;
        }
        if (ge(c)) {
          let m = [], f = /* @__PURE__ */ new Set();
          for (let y of c[Z]) {
            if (typeof y != "object") {
              m.push(p(y));
              continue;
            }
            m.push({ type: "and", values: h(y, f) });
          }
          if (r2.push({ type: "and", v: g2, values: m, subaliases: f }), s)
            for (let y of f)
              s.add(y);
          continue;
        }
        r2.push({ type: "and", values: h(c) });
      }
      return r2;
    });
    __publicField(this, "buildGetQuery", (e, t, s) => {
      var _a2;
      let r2 = [];
      s ?? (s = r2);
      for (let [n2, a] of Object.entries(t)) {
        if (n2 === "ref") {
          if (typeof a == "string")
            s.push([a, e.current, "ref"]);
          else {
            if (!this.isObjectOrTrue(a))
              continue;
            a === true ? r2.push([n2, e.current, "ref"]) : a.addr === true && r2.push([n2, [["addr", e.current, "addr"]]]);
            let { addr: d2 } = a;
            typeof d2 == "string" && s.push([d2, e.current, "addr"]);
          }
          continue;
        }
        let i = e.current, c = n2 === "relation" && ((_a2 = e.bufferBranches.get(e.current)) == null ? void 0 : _a2.relationAlias) || this.addTemplateEntry(e, n2, { type: "type", value: 0 });
        if (typeof a == "object") {
          e.current = c;
          let d2 = this.buildGetQuery(e, a, s);
          d2.length && r2.push([n2, d2]), e.current = i;
        } else
          a === true ? r2.push([n2, c]) : s.push([a, c]);
      }
      return r2;
    });
    __publicField(this, "applyFilters", async (e, t) => {
      if (!e.contentStack.size)
        return t;
      let s = Array.from(e.contentStack.keys()), r2 = await this.engine.send("content:find", s.map((a) => ({ command: "find", data: a })));
      for (let [a, i] of s.entries())
        e.contentStack.get(i).content = r2[a];
      let n2 = (a, i) => {
        if (i.type === "and" && i.subaliases && "v" in i) {
          let c = [...i.values], d2 = t.addrs.filter((u2) => {
            for (let [h, { relationAlias: p }] of e.bufferBranches)
              if (!(i.v === h || i.v === p) && !(i.subaliases.has(h) || i.subaliases.has(p)) && (u2[t.aliases[h]] !== a[t.aliases[h]] || u2[t.aliases[p]] !== a[t.aliases[p]]))
                return false;
            let g2 = c.findIndex((h) => {
              if ("v" in i && "content" in h)
                return h.content.includes(u2[t.aliases[i.v]]);
              if ("type" in h)
                return n2(u2, h);
            });
            return g2 === -1 ? false : (c.splice(g2, 1), true);
          });
          return d2.length < i.values.length ? false : (t.addrs = t.addrs.filter((u2) => !d2.includes(u2)), true);
        }
        for (let c of i.values) {
          let d2;
          if ("v" in i && "content" in c ? d2 = c.content.includes(a[t.aliases[i.v]]) : "type" in c && (d2 = n2(a, c)), d2) {
            if (i.type === "or")
              return true;
          } else if (i.type === "and")
            return false;
        }
        return i.type !== "or";
      };
      return t.addrs = t.addrs.filter((a) => n2(a, { values: e.filteringTree, type: "and" })), t;
    });
    __publicField(this, "buildGetResponse", async (e, t, s, r2) => {
      let n2 = {};
      return await Promise.all(e.map(async ([a, i, c]) => {
        if (typeof i == "string") {
          let d2 = t[s[i]];
          if (c === "addr")
            n2[a] = d2;
          else if (c === "ref") {
            let u2 = P(void 0, false);
            u2.current = d2, n2[a] = this.generate(u2, d2);
          } else
            n2[a] = await r2(d2, i);
        } else
          n2[a] = await this.buildGetResponse(i, t, s, r2);
      })), n2;
    });
    __publicField(this, "transformPromiseTemplate", async (e) => (e.resolveBuffer(), await Promise.all(e.template.map((t) => Promise.all(t.map(async (s) => ({ ...s, value: await s.value })))))));
    this.engine = e;
  }
  async postget(e, t) {
    let s = () => {
    }, r2 = new Promise((d2) => s = d2), n2 = [], a = (d2, u2) => new Promise((g2) => {
      let h = n2.push(d2);
      e.contentAliases.add(u2), r2.then((p) => g2(p[h - 1].value));
    }), i = Promise.all(t.addrs.map((d2) => this.buildGetResponse(e.getQuery, d2, t.aliases, a))), c = n2.length ? await this.engine.send("content:get", n2.map((d2) => ({ command: "get", addr: d2 }))) : [];
    return s(c), await i;
  }
  get(e, t = false) {
    let s = async (r2) => {
      e.resolveBuffer(), e.getQuery = t ? this.buildGetQuery(e, { ref: r2 })[0][1] : this.buildGetQuery(e, r2);
      let n2 = await this.transformPromiseTemplate(e);
      if (!n2)
        return [];
      let a = await this.engine.send("search_template", { templ: n2 });
      return await this.applyFilters(e, a), e.exposeResponse && (e.exposedResponse = a), this.postget(e, a);
    };
    return (r2) => {
      let n2 = s(r2);
      return Object.defineProperty(n2, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, e, n2, s.bind(this, r2)) }), n2;
    };
  }
  link(e) {
    return async (...t) => {
      if (!t.length)
        return 0;
      let s = e.bufferBranches.get(e.bufferCurrent);
      if (!s)
        throw new Error("No buffer property found.");
      let r2 = s.property;
      e.buffer = [], e.bufferCurrent = "";
      let n2;
      if (e.template.length)
        n2 = await this.many(e, { addr: true });
      else if (e.current)
        n2 = [e.current];
      else
        return 0;
      if (!n2.length)
        return 0;
      let a = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), c, d2;
      for (let [m, f] of t.entries())
        if (typeof f != "object" && typeof f != "function") {
          J(f);
          let y = typeof f == "number" ? Number.isInteger(f) ? "int" : "float" : "string";
          a.add({ data: f, type: y });
        } else if (f[T])
          for (let y of await f.ref.addr.many)
            i.add(y);
        else if (f[q]) {
          let y = await f.create;
          if (Array.isArray(y))
            for (let { [_]: x } of y)
              i.add(x);
          else
            i.add(y[_]);
        } else if (Array.isArray(f))
          for (let y of f)
            y[_] && i.add(y[_]);
        else
          f[_] ? i.add(f[_]) : t.length === 2 && m === 1 && (d2 = f);
      let u2 = P();
      for (let m of n2) {
        u2.current = m, u2.isReverse = e.isReverse;
        let f = "";
        for (let [y, x] of Array.from(i).entries())
          f = this.addTemplateEntry(u2, r2, { type: "addr", value: x }, y);
        if (d2 && f) {
          let y = u2.bufferBranches.get(f), x = u2.current;
          u2.current = y.relationAlias;
          let I = this.buildCreationTemplate(u2, d2, false, true);
          ue.call(this, u2, I, d2), c = u2.current, u2.current = x;
        }
        for (let [y, x] of Array.from(a).entries()) {
          let I = this.addTemplateEntry(u2, r2, { type: "type", value: k.LinkVar }, y);
          u2.linksToFill[I] = x;
        }
      }
      let g2 = await this.transformPromiseTemplate(u2);
      if (!g2)
        throw new Error("Failed to generate template");
      let h = await this.engine.send("generate_template", { templ: g2 }), p = Object.entries(u2.linksToFill);
      if (p.length && await this.engine.send("content:set", p.map(([m, { data: f, type: y }]) => ({ command: "set", addr: h.addrs[h.aliases[m]], type: y, data: f }))), c) {
        let m = h.addrs[h.aliases[c]], f = P(void 0, false);
        return f.current = m, f.relations = e.relations.map((y) => h.addrs[h.aliases[y]]), this.generate(f, m);
      }
      return n2.length * (i.size + a.size);
    };
  }
  unlink(e) {
    return async (...t) => {
      let s = e.bufferBranches.get(e.bufferCurrent);
      if (!s)
        throw new Error("No buffer property found.");
      let r2 = s.relationAlias, n2 = e.current, a = await this.transformPromiseTemplate(e);
      if (!a)
        return false;
      let i = await this.engine.send("search_template", { templ: a }), c = (p) => {
        let m = e.contentStack.get(p);
        return m || e.contentStack.set(p, m = { content: p }), m;
      }, d2 = [];
      for (let p of t)
        typeof p == "object" || typeof p == "function" || d2.push(c(p));
      if (d2.length) {
        let p = i.addrs;
        await this.applyFilters(e, i);
        let m = i.addrs.map((y) => y[i.aliases[n2]]);
        i.addrs = p.filter((y) => m.includes(y[i.aliases[n2]])), e.filteringTree = [{ type: "and", v: e.current, values: d2 }], await this.applyFilters(e, i);
        let f = i.addrs.map((y) => y[i.aliases[r2]]);
        return await this._deleteAddrs(f);
      }
      if (await this.applyFilters(e, i), !i.addrs.length)
        return 0;
      if (!t.length)
        return await this._deleteAddrs(i.addrs.map((p) => p[i.aliases[r2]]));
      let u2 = i.addrs.map((p) => ({ addr: p[i.aliases[String(e.current)]], relation: p[i.aliases[r2]] })), g2 = /* @__PURE__ */ new Set();
      for (let p of t)
        if (!(typeof p != "object" && typeof p != "function"))
          if (p[T])
            for (let m of await p.ref.addr.many)
              g2.add(m);
          else
            for (let m of Array.isArray(p) ? p : [p])
              m[_] && g2.add(m[_]);
      let h = u2.reduce((p, m) => (g2.has(m.addr) && p.push(m.relation), p), []);
      return await this._deleteAddrs(h);
    };
  }
  update(e) {
    return async (...t) => {
      let s = () => ({ linked: 0, unlinked: 0 });
      if (!t.length)
        return s();
      let r2 = e.bufferBranches.get(e.bufferCurrent);
      if (!r2)
        throw new Error("No buffer property found.");
      let n2 = r2.property, a = r2.relationAlias, i = e.clone;
      e.buffer = [], e.bufferCurrent = "";
      let c;
      if (e.template.length)
        c = await this.many(e, { addr: true });
      else if (e.current)
        c = [e.current];
      else
        return s();
      if (!c.length)
        return s();
      let d2 = /* @__PURE__ */ new Set(), u2 = /* @__PURE__ */ new Set();
      for (let w2 of t)
        if (typeof w2 != "object" && typeof w2 != "function") {
          J(w2);
          let b = typeof w2 == "number" ? Number.isInteger(w2) ? "int" : "float" : "string";
          d2.add({ data: w2, type: b });
        } else if (w2[T])
          for (let b of await w2.ref.addr.many)
            u2.add(b);
        else if (w2[q]) {
          let b = await w2.create;
          if (Array.isArray(b))
            for (let { [_]: A } of b)
              u2.add(A);
          else
            u2.add(b[_]);
        } else
          for (let b of Array.isArray(w2) ? w2 : [w2])
            b[_] && u2.add(b[_]);
      let g2 = [], h = await this.transformPromiseTemplate(i);
      if (!h)
        return false;
      let p = await this.engine.send("search_template", { templ: h });
      await this.applyFilters(i, p);
      for (let w2 of p.addrs) {
        let b = w2[p.aliases[String(i.current)]], A = w2[p.aliases[a]];
        u2.has(b) ? u2.delete(b) : g2.push(A);
      }
      let m = P();
      for (let w2 of c) {
        m.current = w2;
        for (let [b, A] of Array.from(u2).entries())
          this.addTemplateEntry(m, n2, { type: "addr", value: A }, b);
        for (let [b, A] of Array.from(d2).entries()) {
          let H = this.addTemplateEntry(m, n2, { type: "type", value: k.LinkVar }, b);
          e.linksToFill[H] = A;
        }
      }
      let f = await this.transformPromiseTemplate(m);
      if (!f)
        throw new Error("Failed to generate template");
      let y = await this.engine.send("generate_template", { templ: f }), x = Object.entries(e.linksToFill);
      x.length && await this.engine.send("content:set", x.map(([w2, { data: b, type: A }]) => ({ command: "set", addr: y.addrs[y.aliases[w2]], type: A, data: b })));
      let I = await this._deleteAddrs(g2);
      return { linked: c.length * (u2.size + d2.size), unlinked: I };
    };
  }
  async delete(e) {
    let t = await this.many(e, { addr: true });
    return await this._deleteAddrs(t);
  }
  async _deleteAddrs(e) {
    return e.length ? (await this.engine.send("delete_elements", e))[0] ? e.length : false : 0;
  }
  async one(e, t) {
    var _a2;
    let s = await this.transformPromiseTemplate(e);
    if (!s)
      return;
    let r2 = await this.engine.send("search_template", { templ: s });
    if (!r2)
      throw new TypeError("There is likely an issue with sc-machine");
    await this.applyFilters(e, r2), e.exposeResponse && (e.exposedResponse = r2);
    let n2 = (_a2 = r2.addrs[0]) == null ? void 0 : _a2[r2.aliases[String(e.current)]];
    if (n2)
      return t === true ? { addr: n2 } : (t == null ? void 0 : t.addr) ? n2 : (await this.engine.send("content:get", [{ command: "get", addr: n2 }]))[0].value;
  }
  async many(e, t) {
    let s = await this.transformPromiseTemplate(e);
    if (!s)
      return [];
    let r2 = await this.engine.send("search_template", { templ: s });
    if (!r2)
      throw new TypeError("There is likely an issue with sc-machine");
    await this.applyFilters(e, r2), e.exposeResponse && (e.exposedResponse = r2);
    let n2 = r2.addrs.map((a) => a[r2.aliases[String(e.current)]]);
    return n2.length ? t === true ? n2.map((a) => ({ addr: a })) : (t == null ? void 0 : t.addr) ? n2 : (await this.engine.send("content:get", n2.map((a) => ({ command: "get", addr: a })))).map((a) => a.value) : [];
  }
  where(e, t) {
    return (s) => {
      let r2 = e.isReverse;
      if (Array.isArray(s)) {
        let n2 = [];
        for (let a of s)
          if (a[T]) {
            if (!a[T].initial)
              throw new TypeError("Query is not allowed to be used in filtering.");
            e.isReverse = true, this.addTemplateEntry(e, "element", a[T].currentItem, 0, "buffer");
          } else
            n2.push({ type: "and", values: this.processWhere(e, t ? { ref: a } : a, e.contentAliases) });
        e.filteringTree.push({ type: "or", values: n2 });
      } else if (s[T]) {
        if (!s[T].initial)
          throw new TypeError("Query is not allowed to be used in filtering.");
        e.isReverse = true, this.addTemplateEntry(e, "element", s[T].currentItem, 0, "buffer");
      } else
        e.filteringTree.push(...this.processWhere(e, t ? { ref: s } : s, e.contentAliases));
      return e.isReverse = r2, t ?? this.generate(e);
    };
  }
  normalizeCombinations(e) {
    let t = Object.entries(e), s = t.reduce((n2, [, a]) => Array.isArray(a) ? n2 * a.length : n2, 1), r2 = [];
    for (let n2 = 0; n2 < s; n2++) {
      let a = [], i = s;
      t.forEach(([c, d2]) => {
        Array.isArray(d2) ? (i /= d2.length, a.push([c, d2[Math.floor(n2 / i) % d2.length]])) : a.push([c, d2]);
      }), r2.push(a);
    }
    return r2;
  }
  buildCreationTemplate(e, t, s = false, r2 = false, n2) {
    let a = [], i = Array.isArray(t) ? t : [t];
    for (let [c, d2] of i.entries()) {
      if (d2 instanceof O)
        continue;
      let u2 = this.normalizeCombinations(d2);
      for (let [g2, h] of u2.entries()) {
        let p = e.current;
        if (!s && !r2) {
          e.index++;
          let m = `_c${e.index}`, f = Object.fromEntries(h);
          if ("sc" in f && f.sc & k._Edge) {
            if (!f.from)
              throw new TypeError("Cannot create an edge without 'from' property");
            if (!f.to)
              throw new TypeError("Cannot create an edge without 'to' property");
            e.aliasItems.set(m, { type: "type", value: f.sc, alias: m });
          } else {
            if (f.from)
              throw new TypeError("Cannot use 'from' property with a non-edge element");
            if (f.to)
              throw new TypeError("Cannot use 'to' property with a non-edge element");
          }
          e.template.push([e.currentItem, { type: "type", value: k.EdgeAccessVarPosPerm }, f.from ? { type: "alias", value: m } : { type: "type", value: f.sc ?? k.NodeVar, alias: m }]), a.push(m), e.current = m;
        }
        for (let [m, [f, y]] of h.entries()) {
          if (f === "is") {
            this.buildCreationTemplate(e, y, true, r2);
            continue;
          }
          if (typeof y == "object" || typeof y == "function") {
            let x = null, I, w2;
            if (!y[q] && Object.keys(y).length === 2 && "value" in y && "relation" in y) {
              x = y.relation, y = y.value;
              let b = e.current;
              e.current = "_", I = e.template.length;
              let A = e.innerHats.length;
              this.buildCreationTemplate(e, x, false, true, A), A !== e.innerHats.length && (w2 = e.innerHats.splice(A)), e.current = b;
            }
            if (y instanceof O)
              e.innerHats.push({ searchTarget: y, current: e.current, key: f, isReverse: s, customRelation: x, dynamicRoot: n2 ?? e.dynamicRoot, insertPosition: I }), w2 && e.innerHats.push(...w2);
            else {
              let { target: b, aliases: A } = y[q], H = (m * u2.length + g2) * i.length + c;
              Object.getOwnPropertyDescriptor(b, "resolveBuffer").value.call(b);
              let Y = Object.getOwnPropertyDescriptor(b, "template").value;
              Y.forEach((F) => F.forEach((C) => {
                C.type === "alias" ? C.value = H + C.value : C.alias && (C.alias = H + C.alias);
              })), f === "from" || f === "to" ? e.pre_template.push(...Y) : e.template.push(...Y);
              let ve = Object.getOwnPropertyDescriptor(b, "linksToFill").value;
              for (let [F, C] of Object.entries(ve))
                e.linksToFill[H + F] = C;
              let _e = Object.getOwnPropertyDescriptor(b, "innerHats").value;
              for (let { searchTarget: F, current: C, key: V, isReverse: xe } of _e)
                e.innerHats.push({ searchTarget: F, current: H + C, key: V, isReverse: xe });
              for (let [F, C] of A.entries()) {
                if (f === "from" || f === "to") {
                  let V = e.edgeData.get(C);
                  V ? V[f === "from" ? 0 : 2].value = H + C : e.edgeData.set(C, V = [{ type: "alias", value: H + C }, e.aliasItems.get(C), { type: "alias", value: H + C }]);
                  continue;
                }
                this.addTemplateEntry(e, f, { type: "alias", value: H + C }, F);
              }
            }
          } else {
            if (f === "sc" || f === "from" || f === "to")
              continue;
            e.isReverse = s;
            let x = this.addTemplateEntry(e, f, { type: "type", value: k.LinkVar });
            J(y);
            let I = typeof y == "number" ? Number.isInteger(y) ? "int" : "float" : "string";
            e.linksToFill[x] = { data: y, type: I };
          }
        }
        e.current = p;
      }
    }
    return a;
  }
  generate(e = P(), t) {
    return t && Object.defineProperty(e, "ref", { configurable: true, writable: false, enumerable: true, value: { addr: t } }), new Proxy(e, { construct: (s, r2) => {
      if (s.template.length || s.isReverse || s.isDollar || !s.current)
        throw new TypeError("Unexpected constructor call");
      if (r2.length && r2.length !== 1)
        throw new TypeError("Concept constructor expects only 1 argument");
      let n2 = s.clone, a = r2[0] ?? {}, i = this.buildCreationTemplate(n2, a);
      return new Proxy(D(), { get: (c, d2) => {
        switch (d2) {
          case q:
            return { target: n2, aliases: i };
          case "create":
            return (async () => (await ue.call(this, n2), await be.call(this, n2, i, a)))();
        }
      } });
    }, get: (s, r2) => {
      if (r2 === "constructor")
        return;
      if (r2 === "valueOf")
        return () => "Magic Query";
      if (r2 === "toString")
        return "hola";
      if (r2 === "then")
        return;
      if (r2 === _)
        return t;
      if (r2 === T && !t)
        return s;
      if (typeof r2 == "symbol")
        return;
      if (!s.current) {
        let i = s.clone, c = r2.match(/^Element(([A-Z0-9_]|$).+)/);
        if (c) {
          let u2 = `rrel${c[1].replace(/[A-Z]+/g, (g2) => `_${g2.toLowerCase()}`)}`;
          return i.current = this.engine.getKeynode(u2), i.current.idtf = u2, i.initial = u2, this.generate(i);
        }
        let d2 = `${r2.replace(/[A-Z]+/g, (u2) => `_${u2.toLowerCase()}`)}`;
        return i.current = this.engine.getKeynode(`concept${d2}`), i.current.idtf = `concept${d2}`, i.initial = d2.slice(1), this.generate(i);
      }
      if (r2 === "$") {
        let i = s.clone;
        return i.isDollar = true, this.generate(i);
      }
      if (t && r2 === "relations")
        return s.relations;
      let n2 = s.clone;
      if (r2 === "relation") {
        n2.resolveBuffer();
        let i = n2.bufferBranches.get(n2.current).relationAlias;
        return n2.current = i, this.generate(n2);
      }
      if (r2 === "one") {
        n2.contentAliases.add(n2.bufferCurrent || n2.current);
        let i = this.one(n2);
        return Object.defineProperty(i, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, i, this.one.bind(this, n2)) }), i;
      }
      if (r2 === "many") {
        n2.contentAliases.add(n2.bufferCurrent || n2.current);
        let i = this.many(n2);
        return Object.defineProperty(i, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, i, this.many.bind(this, n2)) }), i;
      }
      if (r2 === "write")
        return async (i, c) => {
          J(i, c), c ?? (c = typeof i == "number" ? Number.isInteger(i) ? "int" : "float" : "string");
          let d2 = await this.many(n2.clone, { addr: true });
          return d2.length ? (await this.engine.send("content:set", d2.map((u2) => ({ command: "set", addr: u2, data: i, type: c }))), d2.length) : await this.link(n2)(i);
        };
      if (r2 === "get")
        return this.get(n2);
      if (r2 === "where")
        return this.where(n2);
      if (r2 === "link")
        return this.link(n2);
      if (r2 === "unlink")
        return this.unlink(n2);
      if (r2 === "update")
        return this.update(n2);
      if (r2 === "ref") {
        let i = new Proxy(t ? { addr: t } : D(), { get: (c, d2) => {
          switch (d2) {
            case "addr":
              return t || new Proxy(D(), { get: (u2, g2) => {
                switch (g2) {
                  case "one": {
                    let h = this.one(n2, { addr: true });
                    return Object.defineProperty(h, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, h, this.one.bind(this, n2, { addr: true })) }), h;
                  }
                  case "many": {
                    let h = this.many(n2, { addr: true });
                    return Object.defineProperty(h, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, h, this.many.bind(this, n2, { addr: true })) }), h;
                  }
                }
              } });
            case "one": {
              if (t)
                return;
              let u2 = async () => {
                let h = await this.one(n2, { addr: true });
                if (!h)
                  return;
                let p = P(void 0, false);
                return p.current = h, this.generate(p, h);
              }, g2 = u2();
              return Object.defineProperty(g2, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, g2, u2) }), g2;
            }
            case "many": {
              if (t)
                return;
              let u2 = async () => (await this.many(n2, { addr: true })).map((p) => {
                let m = P(void 0, false);
                return m.current = p, this.generate(m, p);
              }), g2 = u2();
              return Object.defineProperty(g2, "reactive", { enumerable: false, configurable: false, get: () => $(this.engine, n2, g2, u2) }), g2;
            }
            case "where":
              return t ? void 0 : this.where(n2, i);
            case "get":
              return t ? void 0 : this.get(n2, true);
            case "delete":
              return t ? this._deleteAddrs([t]) : this.delete(n2);
          }
        } });
        return i;
      }
      if (r2 === "clone")
        return n2.clone;
      if (r2 === "scs")
        return n2;
      let a = this.addTemplateEntry(n2, r2, { type: "type", value: 0 }, 0, "buffer");
      return n2.bufferCurrent = a, this.generate(n2);
    }, apply: (s, r2, n2) => {
      if (!n2.length)
        return;
      if (!s.initial && !s.isDollar)
        throw new TypeError("System idtf can only be accessed from the first element of the chain");
      if (n2[1] !== void 0) {
        if (typeof n2[1] == "number") {
          let u2 = P(void 0, false);
          return u2.current = n2[1], this.generate(u2, n2[1]);
        }
        let d2 = `Expected number but got ${typeof n2[1]}: ${JSON.stringify(n2[1])}`;
        throw new TypeError(`Invalid type of sc-addr specified. ${d2}.`);
      }
      let a = s.clone;
      a.index++;
      let i = `_v${a.index}`, c = a.isDollar ? n2[0][0] : `${a.initial}_${n2[0][0]}`;
      return a.template.push([a.currentItem, { type: "type", value: k.EdgeAccessVarPosPerm }, { type: "addr", value: this.engine.getKeynode(c), alias: i }]), a.initial = "", a.isDollar = false, a.current = i, this.generate(a);
    } });
  }
};
var we = class {
  constructor(e, t) {
    __publicField(this, "engine");
    __publicField(this, "magicModule");
    this.engine = new G(e, t), this.magicModule = new X(this.engine);
  }
  get magic() {
    return this.magicModule.generate();
  }
  $disconnect() {
    return this.engine.disconnect();
  }
  [Symbol.dispose]() {
    return this.engine.disconnect();
  }
  async [Symbol.asyncDispose]() {
    return await this.engine.disconnect();
  }
};
export {
  Fe as $and,
  we as Enneract,
  k as ScType,
  u as Signal,
  r as batch,
  w as computed,
  g as deepSignal,
  E as effect,
  d as signal,
  He as smartBatch,
  n as untracked
};
//# sourceMappingURL=@ennealand_enneract.js.map
